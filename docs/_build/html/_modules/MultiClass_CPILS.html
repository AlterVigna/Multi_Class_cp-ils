

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MultiClass_CPILS &mdash; Multi_Class-CPILS 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Multi_Class-CPILS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">Multi_Class_CP-ILS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Multi_Class-CPILS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">MultiClass_CPILS</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MultiClass_CPILS</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pydoc</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;display.max_columns&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">to_hex</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">colorsys</span>


<span class="kn">import</span> <span class="nn">utils</span>
<span class="kn">import</span> <span class="nn">cpils</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span> <span class="nn">tqdm.notebook</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">LabelEncoder</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">BaseEstimator</span>

<div class="viewcode-block" id="MultiClass_CP_ILS">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS">[docs]</a>
<span class="k">class</span> <span class="nc">MultiClass_CP_ILS</span><span class="p">():</span>
<span class="w">   </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A multi-class extension of the CP_ILS method designed for binary classification.</span>
<span class="sd">    </span>
<span class="sd">    This class handles multi-class classification scenarios by transforming them into binary classification problems in different modes. </span>
<span class="sd">    The supported modes include 1v1, 1vAll, 1vAll_Spec, Allv1, and All_Specv1, which specifies how the multi-class problem is decomposed into binary ones.</span>


<span class="sd">    Constants:</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    MODE_1V1 : str</span>
<span class="sd">        Constant representing the 1-vs-1 mode.</span>
<span class="sd">    MODE_1VALL : str</span>
<span class="sd">        Constant representing the 1-vs-All mode.</span>
<span class="sd">    MODE_1VALL_SPEC : str</span>
<span class="sd">        Constant representing the 1-vs-All (Specific) mode.</span>
<span class="sd">    MODE_ALLV1 : str</span>
<span class="sd">        Constant representing the All-vs-1 mode.</span>
<span class="sd">    MODE_ALL_SPECV1 : str</span>
<span class="sd">        Constant representing the All-vs-1 (Specific) mode.</span>

<span class="sd">    Attributes:</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    flatten : function</span>
<span class="sd">        A lambda function to flatten multi-dimensional arrays.</span>
<span class="sd">    __mbbox_model : model</span>
<span class="sd">        The multi-class black-box classifier model used for predictions, also referred as MBB</span>
<span class="sd">    __train_set : pd.DataFrame</span>
<span class="sd">        The training dataset used to generate latent spaces.</span>
<span class="sd">    __test_set : pd.DataFrame</span>
<span class="sd">        The test dataset used for validation and counterfactual generation.</span>
<span class="sd">    __mode : str</span>
<span class="sd">        The mode of classification, which defines how the multi-class problem is treated.</span>
<span class="sd">    __class_combinations : list</span>
<span class="sd">        A list of class combinations generated according to the mode.</span>
<span class="sd">        </span>
<span class="sd">    __dict_train_datasets : dict</span>
<span class="sd">        A dictionary storing the training datasets for each class combination.</span>
<span class="sd">    __dict_test_datasets : dict</span>
<span class="sd">        A dictionary storing the test datasets for each class combination.</span>
<span class="sd">    __dict_latent_spaces : dict</span>
<span class="sd">        A dictionary storing the latent spaces for each class combination.</span>
<span class="sd">    __hex_colors_for_classes : dict</span>
<span class="sd">        A dictionary storing the hexadecimal colors for each class, used for plotting points with same class color in all exp.</span>

<span class="sd">    Public Methods:</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    __init__(self, bbox_model, train_set, test_set, target_class=&quot;class&quot;, mode=MODE_1V1):</span>
<span class="sd">        Initializes the MultiClass_CP_ILS object with the given dataset, model, and classification mode.</span>
<span class="sd">        </span>
<span class="sd">    generate_ls(self, latent_dim_k=2, early_stop_param=5, timer=False):</span>
<span class="sd">        Generates latent spaces for each class combination using CP-ILS method, leveraging a black-box model.</span>

<span class="sd">    generate_counterfactuals(self, test_instance, change_f, max_f, counter_classes=-1, filtering_mode=&quot;&quot;, debug=True):</span>
<span class="sd">        Generates counterfactual explanations for a given test instance by modifying the input features for a specific mode</span>

<span class="sd">    execute_ranking_of_counterfactuals(self, test_instance, df_counterfactuals, ranking=&quot;proximity&quot;, group_by_class=True, top_k=-1):</span>
<span class="sd">        Function to rank with a certain ranking criterion a list of counterfactuals, obtained respect to a test_instance</span>

<span class="sd">    plot_ls_comb(self,target,comb=None,class_name=None):</span>
<span class="sd">        Function to plot a specific combination of latent space callable from external.</span>
<span class="sd">    </span>
<span class="sd">    plot_ls_comb_compare(self,comb=None,class_name=None):</span>
<span class="sd">       Function to plot and compare specific combination of latent space callable from external.</span>
<span class="sd">    </span>
<span class="sd">    plot_ls_training_losses(self,comb=None,class_name=None):</span>
<span class="sd">        Function to plot specific combination of train_test losses callable from external.</span>

<span class="sd">    execute_testing_on_data(self,test_name,test_instances,change_f,max_f,filtering_mode=&quot;acceptable&quot;,debug=False):</span>
<span class="sd">        Automatic procedure to print on external files the counterfactuals main information and treat them separately</span>

<span class="sd">    save_latent_spaces(self, filename):</span>
<span class="sd">        Saves the latent spaces to a file using pickle.</span>

<span class="sd">    load_latent_spaces(self, filename):</span>
<span class="sd">        Loads latent spaces from a file using pickle.</span>

<span class="sd">    get_ls_of_class(self, class_name):</span>
<span class="sd">        Returns the latent spaces specific to a given class.</span>

<span class="sd">    get_ls_of_not_class(self, class_name):</span>
<span class="sd">        Returns the latent spaces for all classes except the specified one.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    Private Methods:</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    __adjust_target_class(self, target_name, train_set,test_set):</span>
<span class="sd">        Adjusts the target class column to be the last column in the dataset and renames it to &#39;class&#39;.</span>

<span class="sd">    __build_dataset_idx_num_cat(self):</span>
<span class="sd">        Builds index lists for numerical and categorical attributes in the dataset.</span>

<span class="sd">    __assign_color_to_classes(self):</span>
<span class="sd">        Assigns a unique color to each class using HLS color space.</span>

<span class="sd">    __prepare_datasets(self):</span>
<span class="sd">        Prepares datasets for the specified classification mode by splitting them into appropriate combinations of classes.</span>
<span class="sd">    __generate_counterfactuals_1v1(self,test_instance,change_f,max_f,y_pred,counter_classes=-1,filtering_mode=&quot;&quot;,debug=True):</span>
<span class="sd">        Generates counterfactual explanations for a given test instance using the modality 1v1 </span>

<span class="sd">    __generate_counterfactuals_1vAll_AllSpec(self,test_instance,change_f,max_f,y_pred,counter_classes=-1,filtering_mode=&quot;&quot;,debug=True):</span>
<span class="sd">        Generates counterfactual explanations for a given test instance using the modality 1vALL or 1vALLSpec</span>

<span class="sd">    __generate_counterfactuals_Allv1_Allv1Spec(self,test_instance,change_f,max_f,y_pred,counter_classes=-1,filtering_mode=&quot;&quot;,debug=True):</span>
<span class="sd">        Generates counterfactual explanations for a given test instance using the modality Allv1 or AllSpecV1</span>

<span class="sd">    __plot_ls_directions(self,latent,X_instances,title=&quot;&quot;):</span>
<span class="sd">        Function to plot the binary classifier counterfactuals direction in a latent space</span>

<span class="sd">    __plot_ls_class_scatter_plot(self,Z_train,Y_labels,title=&quot;&quot;,target=&quot;classes_MBB&quot;,comb=(&quot;None&quot;,&quot;All&quot;)):</span>
<span class="sd">        Function to plot the 2D scatter plot of a latent space, optionally targeting a specific classes combination </span>

<span class="sd">    __prepare_ls_class_scatter_plot(self,ax,Z_train,Y_labels,title=&quot;&quot;,comb=(&quot;None&quot;,&quot;All&quot;)):</span>
<span class="sd">        Function to plot the 2D scatter plot of a latent space comparing the MBB with the BBB</span>

<span class="sd">    __plot_ls_losses(self,losses,title=&quot;&quot;):</span>
<span class="sd">        Function to plot the losses of training and testing during the latent spaces generations</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#Constants</span>
    <span class="n">MODE_1V1</span><span class="o">=</span><span class="s2">&quot;1v1&quot;</span>
    <span class="n">MODE_1VALL</span><span class="o">=</span><span class="s2">&quot;1vAll&quot;</span>
    <span class="n">MODE_1VALL_SPEC</span><span class="o">=</span><span class="s2">&quot;1vAll_Spec&quot;</span>
    <span class="n">MODE_ALLV1</span><span class="o">=</span><span class="s2">&quot;Allv1&quot;</span>
    <span class="n">MODE_ALL_SPECV1</span><span class="o">=</span><span class="s2">&quot;All_Specv1&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bbox_model</span><span class="p">:</span> <span class="n">BaseEstimator</span><span class="p">,</span><span class="n">train_set</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">test_set</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">bbox_structure</span><span class="p">:</span><span class="n">BaseEstimator</span><span class="p">,</span><span class="n">target_class</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">,</span><span class="n">mode</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="n">MODE_1V1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Constructor method for initialization of attributes, preparing datasets in proper format and for class combinations.</span>
<span class="sd">            Setting the target class with name class if different, locate what indexes are categorical and numerical, build the</span>
<span class="sd">            needed combination used for generation of latent spaces and further to generate counterfactuals depending on the mode</span>
<span class="sd">            passed.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                bbox_model (BaseEstimator): A scikit-learn trained model used for multi-class classification (black box model).</span>
<span class="sd">                train_set (pd.DataFrame): DataFrame containing the training dataset.</span>
<span class="sd">                test_set (pd.DataFrame): DataFrame containing the test dataset.</span>
<span class="sd">                target_class (str): The target class to predict. Default is &quot;class&quot;.</span>
<span class="sd">                bbox_structure (BaseEstimator): The black box model to train inside the specific combination</span>
<span class="sd">                mode (str): The mode for generating counterfactuals. Default is MODE_1V1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">MODE_ALLOWED</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1V1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1VALL</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1VALL_SPEC</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_ALLV1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_ALL_SPECV1</span><span class="p">]</span>
        
        <span class="c1">#Global utility function for flatteing, used also in original CP_ILS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">m</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>

        <span class="c1">#Preliminary: check if target and mode passed are correct </span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target_class</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">train_set</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">target_class</span><span class="si">}</span><span class="s2"> is not a valid target class. </span><span class="se">\n</span><span class="s2">Please insert one of </span><span class="si">{</span><span class="n">train_set</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">MODE_ALLOWED</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2"> is not one of the allowed modality. Please insert one of  </span><span class="si">{</span><span class="n">MODE_ALLOWED</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__adjust_target_class</span><span class="p">(</span><span class="n">target_class</span><span class="p">,</span><span class="n">train_set</span><span class="p">,</span><span class="n">test_set</span><span class="p">)</span>
    
        <span class="c1">#Global attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">=</span><span class="n">bbox_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="o">=</span><span class="n">train_set</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="o">=</span><span class="n">test_set</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">=</span><span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bbox_structure</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">bbox_structure</span><span class="p">)</span>
 
        <span class="c1">#Attributes related to the dataset provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__build_dataset_idx_num_cat</span><span class="p">()</span>
         
        <span class="c1">#Group of dataset per combination of classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict_test_datasets</span><span class="o">=</span><span class="p">{}</span>

        <span class="c1">#Latent spaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="o">=</span><span class="p">{}</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__prepare_datasets</span><span class="p">()</span> 

    <span class="c1">## Utility TO BE REMOVED (just for quick init)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; def get_ls(self):</span>
<span class="sd">        return self.__dict_latent_spaces &quot;&quot;&quot;</span>
        
    <span class="c1">## Utility TO BE REMOVED (just for quick init)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; def set_ls(self,latent_spaces):</span>
<span class="sd">        self.__dict_latent_spaces=latent_spaces &quot;&quot;&quot;</span>

    
<div class="viewcode-block" id="MultiClass_CP_ILS.save_latent_spaces">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.save_latent_spaces">[docs]</a>
    <span class="k">def</span> <span class="nf">save_latent_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Save the generated latent spaces into a file.</span>

<span class="sd">            Args:</span>
<span class="sd">                filename (str): The path where the latent spaces will be saved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Latent space saved in </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiClass_CP_ILS.load_latent_spaces">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.load_latent_spaces">[docs]</a>
    <span class="k">def</span> <span class="nf">load_latent_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Load the generated latent spaces from a file.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                filename (str): The string containing the path to load the file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Latent space loaded from </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiClass_CP_ILS.get_ls_of_class">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.get_ls_of_class">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ls_of_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_name</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Method to return the latent space where the class with class_name is involved.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                class_name (str): The name of the class to be reserched in latents spaces combinations</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                    list: A list of tuples, where each tuple contains a latent space key and its corresponding value,</span>
<span class="sd">                          filtered to include only those where class_name is present in the key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="MultiClass_CP_ILS.get_ls_of_not_class">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.get_ls_of_not_class">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ls_of_not_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">class_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to return the latent space where the class with class_name is NOT involved.</span>

<span class="sd">        Args:</span>
<span class="sd">            class_name (str): The name of the class to be researched in latent space combinations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of tuples, where each tuple contains a latent space key and its corresponding value,</span>
<span class="sd">                filtered to include only those where class_name is NOT present in the key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">class_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span></div>



    <span class="c1">## Utility TO BE REMOVED (just for test)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; def get_dict_train_dataset(self):</span>
<span class="sd">        return self.__dict_train_datasets &quot;&quot;&quot;</span>

    <span class="c1">## Utility TO BE REMOVED (just for test)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; def get_dict_test_dataset(self):</span>
<span class="sd">        return self.__dict_test_datasets &quot;&quot;&quot;</span>
    
    <span class="c1">## Utility TO BE REMOVED (just for test)    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; def get_hex_colors(self):</span>
<span class="sd">        return self.__hex_colors_for_classes &quot;&quot;&quot;</span>

    
<span class="c1">##########     PRE-PROCESSING PART    ##########</span>

    <span class="k">def</span> <span class="nf">__adjust_target_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">target_name</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">train_set</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">test_set</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function move at the last column position the target class and rename it, if necessary, as class.</span>
<span class="sd">            In addition, for each possible class values, it define a color saved in data structure, used to plot the 2D latent spaces scatter plot.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                target_name (str): The class name to be found in the train_set</span>
<span class="sd">                train_set (pd.DataFrame): One of the set where the target class should be moved at last column position</span>
<span class="sd">                test_set (pd.DataFrame): One of the set where the target class should be moved at last column position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">#The class column must be fixed at last position</span>
        <span class="n">new_position</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="n">cols</span> <span class="o">=</span> <span class="n">train_set</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
        <span class="c1"># Remove the column to move and reinsert it at the new position</span>
        <span class="n">cols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_position</span><span class="p">,</span> <span class="n">cols</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target_name</span><span class="p">)))</span>
        
        <span class="n">train_set</span> <span class="o">=</span> <span class="n">train_set</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>
        <span class="n">train_set</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">target_name</span><span class="p">:</span> <span class="s1">&#39;class&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1">#Do the same for test set</span>
        <span class="n">new_position</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> 
        <span class="n">cols</span> <span class="o">=</span> <span class="n">test_set</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">cols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_position</span><span class="p">,</span> <span class="n">cols</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target_name</span><span class="p">)))</span>
        <span class="n">test_set</span> <span class="o">=</span> <span class="n">test_set</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>
        <span class="n">test_set</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">target_name</span><span class="p">:</span> <span class="s1">&#39;class&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">classes</span><span class="o">=</span><span class="n">train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">classes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="o">=</span><span class="n">classes</span>
   
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target class: </span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Now renamed class&quot;</span> <span class="k">if</span> <span class="n">target_name</span> <span class="o">!=</span> <span class="s2">&quot;class&quot;</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Class values are: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__assign_color_to_classes</span><span class="p">()</span>
        
        
    <span class="k">def</span> <span class="nf">__build_dataset_idx_num_cat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function aims to populate the variable __idx_num_cat as in original work of CP_ILS.</span>
<span class="sd">            The __idx_num_cat is a variable containg the dataset information about continous and categorical attributes.</span>
<span class="sd">            The categorical attribute are one-hot-encoded. This variable is necessary to correctly handles categorical columns during </span>
<span class="sd">            the generation of latent space and counterfactuals.</span>

<span class="sd">            It is a list of list, where each sub list contains the indexes referred to the same attribute. </span>
<span class="sd">            E.g if we have 2 Attributes, Age and Gender, where gender can assume the 2 categorical values(M-F) after one hot encoding:</span>
<span class="sd">            the total columns are 3: Age, Gender_M, Gender_F and the list is composed by the elements [[0],[1,2]].</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx_num_cat</span><span class="o">=</span><span class="p">[]</span> 

        <span class="c1">#Fix as starting column_name the name of the class that for sure it is not present</span>
        <span class="n">column_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1">#Detection of one hot categorical feature, that contains _ and consider as unique variable</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="o">.</span><span class="n">columns</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">column</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">column_name</span><span class="p">)):</span>
                <span class="n">new_list</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">idx_num_cat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_list</span><span class="p">)</span>
                <span class="n">column_name</span><span class="o">=</span><span class="n">column</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">__idx_num_cat</span><span class="o">=</span><span class="n">idx_num_cat</span>
        
        <span class="c1">#Save separately the numerical and categorical indexes </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__idx_num_cat</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__idx_num_cat</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Numerical indexes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Categorical indexes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_cat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__idx_num_cat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__assign_color_to_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function assign significantly different colors for each class values saving it as dict</span>
<span class="sd">            self.__hex_colors_for_classes data structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Choose a set of color fixed for classes</span>
        <span class="n">hues</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">))]</span>  <span class="c1"># Distribute hues evenly</span>
        <span class="n">saturation</span><span class="p">,</span> <span class="n">lightness</span> <span class="o">=</span> <span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.5</span>  <span class="c1"># Fixed saturation and lightness for balance</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">{</span><span class="bp">cls</span><span class="p">:</span> <span class="n">colorsys</span><span class="o">.</span><span class="n">hls_to_rgb</span><span class="p">(</span><span class="n">hue</span><span class="p">,</span> <span class="n">lightness</span><span class="p">,</span> <span class="n">saturation</span><span class="p">)</span> <span class="k">for</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">hue</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">,</span> <span class="n">hues</span><span class="p">)}</span>
        <span class="n">hex_colors</span> <span class="o">=</span> <span class="p">{</span><span class="bp">cls</span><span class="p">:</span> <span class="n">to_hex</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__hex_colors_for_classes</span><span class="o">=</span><span class="n">hex_colors</span>


    <span class="k">def</span> <span class="nf">__prepare_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function aims to preparing the training and testing dataset for each possible class combinations depending on the</span>
<span class="sd">            mode selected at the begin.</span>
<span class="sd">            In 1v1 mode: for each possible pair of classes &quot;combinations&quot; filter the samples that are involved for that binary classification</span>
<span class="sd">            In 1vAll or Allv1 mode: for each possible class select its samples entierly and then selecting randomly the remaining (n_classes-1) in equal proportion</span>
<span class="sd">            to obtain the same number of samples of the target class.</span>
<span class="sd">            In 1vAllSpec or Allv1Spec: the procedure is the same of 1vAll-Allv1 but not chosen the sample randomly but the ones most near to the target class.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#Calling this method, at this point the training and testing dataset are supposed to be balanced.</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Modality:  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1V1</span><span class="p">):</span>
            
            <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>
    
                <span class="n">class_i</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#e.g 1</span>
                <span class="n">class_j</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#e.g 3</span>
                
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparation of datasets for combination </span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_j</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict_test_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_j</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1VALL</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_ALLV1</span><span class="p">):</span>
            
            <span class="k">for</span> <span class="n">class_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">:</span>
                <span class="n">comb</span><span class="o">=</span><span class="p">(</span><span class="n">class_value</span><span class="p">,</span><span class="s2">&quot;All&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>

                <span class="n">class_i</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#e.g 1</span>
                <span class="n">class_j</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#e.g ALL</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparation of datasets for combination </span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#Get the number of instances of the target class and obtain the number of sample to use for the other classes</span>
                <span class="n">train_class_i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">]</span>
                <span class="n">no_train_samples_per_class</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">train_class_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">test_class_i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">]</span>
                <span class="n">no_test_samples_per_class</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">test_class_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">train_set_copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">test_set_copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1">#Create new dataframes sampling accordingly to the number obtained, in order to have a balanced datasets.</span>
                <span class="n">final_train_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                <span class="n">final_test_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                
                <span class="k">for</span> <span class="n">cls_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">cls_value</span><span class="o">!=</span><span class="n">class_i</span><span class="p">):</span>
                        <span class="n">no_eff_min_train_samples</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">train_set_copy</span><span class="p">[</span><span class="n">train_set_copy</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">cls_value</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">no_train_samples_per_class</span><span class="p">)</span>
                        <span class="n">no_eff_min_test_samples</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">test_set_copy</span><span class="p">[</span><span class="n">test_set_copy</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">cls_value</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">no_test_samples_per_class</span><span class="p">)</span>
                        <span class="n">final_train_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">final_train_set</span><span class="p">,</span> <span class="n">train_set_copy</span><span class="p">[</span><span class="n">train_set_copy</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">cls_value</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">no_eff_min_train_samples</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">final_test_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">final_test_set</span><span class="p">,</span> <span class="n">test_set_copy</span><span class="p">[</span><span class="n">test_set_copy</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">cls_value</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">no_eff_min_test_samples</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">final_train_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">final_train_set</span><span class="p">,</span> <span class="n">train_set_copy</span><span class="p">[</span><span class="n">train_set_copy</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">cls_value</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">no_train_samples_per_class</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">final_test_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">final_test_set</span><span class="p">,</span> <span class="n">test_set_copy</span><span class="p">[</span><span class="n">test_set_copy</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">cls_value</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">no_test_samples_per_class</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1">#**CONVENTION**:</span>
                <span class="c1">#Lonley class &quot;1&quot; is encoded with class 0</span>
                <span class="c1">#Grouped class &quot;All&quot; is encoded with class 1</span>
                <span class="c1">#This is useful for the testing part in the generation of counterfactual to determine if they are acceptable or not</span>
                
                <span class="c1">#Binarization of the dataset impose as class=0 the class_i, the first in the combination and 1 the others</span>
                <span class="n">final_train_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">final_train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">,</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
                <span class="n">final_train_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">final_train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">!=</span><span class="n">class_i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">final_train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="n">final_train_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">final_train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
                
                <span class="c1">#Binarization of the dataset impose as class=0 the class_i, the first in the combination and 1 the others</span>
                <span class="n">final_test_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">final_test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">,</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
                <span class="n">final_test_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">final_test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">!=</span><span class="n">class_i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">final_test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="n">final_test_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">final_test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
 
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span><span class="o">=</span><span class="n">final_train_set</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict_test_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span><span class="o">=</span><span class="n">final_test_set</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1VALL_SPEC</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_ALL_SPECV1</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">class_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">:</span>
                <span class="n">comb</span><span class="o">=</span><span class="p">(</span><span class="n">class_value</span><span class="p">,</span><span class="s2">&quot;All_Spec&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>
    
                <span class="n">class_i</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#e.g 1</span>
                <span class="n">class_j</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#e.g ALL</span>
    
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparation of datasets for combination </span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#Get the number of instances of the target class and obtain the number of sample to use for the other classes</span>
                <span class="n">train_class_i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">]</span>
                <span class="n">no_train_samples_per_class</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">train_class_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                
                <span class="n">test_class_i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">]</span>
                <span class="n">no_test_samples_per_class</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">test_class_i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">final_train_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                <span class="n">final_train_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">final_train_set</span><span class="p">,</span><span class="n">train_class_i</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">no_train_samples_per_class</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
                <span class="c1">#For each remaining dataset, the points are chosen using the shortest proximity distance to the class_i cluster in even proportion</span>
                <span class="k">for</span> <span class="n">class_value_rim</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">class_value</span><span class="p">]:</span>
                    
                    <span class="c1">#Compute a matrix of distances among multidimentional points and selecting the lowest values</span>
                    <span class="n">train_class_j</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_value_rim</span><span class="p">]</span>
                    <span class="n">dists</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cdist_sample_distance</span><span class="p">(</span><span class="n">train_class_i</span><span class="p">,</span><span class="n">train_class_j</span><span class="p">)</span>
                    <span class="n">flat_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">row_indices</span><span class="p">,</span> <span class="n">col_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">flat_indices</span><span class="p">,</span> <span class="n">dists</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    
                    <span class="n">unique_col_indices</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">col_indices</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_col_indices</span><span class="p">:</span>
                            <span class="n">unique_col_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_col_indices</span><span class="p">)</span> <span class="o">==</span> <span class="n">no_train_samples_per_class</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="n">final_train_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">final_train_set</span><span class="p">,</span><span class="n">train_class_j</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">unique_col_indices</span><span class="p">,:]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1">#The test dataset instead is chosen randomly because it is not possibile to know in advance what data could be presented</span>
                <span class="n">test_set_copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__test_set</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">final_test_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
                
                <span class="k">for</span> <span class="n">cls_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">cls_value</span><span class="o">!=</span><span class="n">class_i</span><span class="p">):</span>
                        <span class="n">final_test_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">final_test_set</span><span class="p">,</span> <span class="n">test_set_copy</span><span class="p">[</span><span class="n">test_set_copy</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">cls_value</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">no_test_samples_per_class</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">final_test_set</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">final_test_set</span><span class="p">,</span> <span class="n">test_set_copy</span><span class="p">[</span><span class="n">test_set_copy</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">cls_value</span><span class="p">]</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">no_test_samples_per_class</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


                <span class="c1">#**CONVENTION**:</span>
                <span class="c1">#Lonley class &quot;1&quot; is encoded with class 0</span>
                <span class="c1">#Grouped class &quot;All&quot; is encoded with class 1</span>
                <span class="c1">#This is useful for the testing part in the generation of counterfactual to determine if they are acceptable or not</span>
                
                <span class="c1">#Binarization of the dataset impose as class=0 the class_i, the first in the combination and 1 the others</span>
                <span class="n">final_train_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">final_train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">,</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
                <span class="n">final_train_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">final_train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">!=</span><span class="n">class_i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">final_train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="n">final_train_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">final_train_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>

                <span class="c1">#Binarization of the dataset impose as class=0 the class_i, the first in the combination and 1 the others</span>
                <span class="n">final_test_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">final_test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">class_i</span><span class="p">,</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
                <span class="n">final_test_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">final_test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">!=</span><span class="n">class_i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">final_test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="n">final_test_set</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">final_test_set</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==-</span><span class="mi">1</span><span class="p">),</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span><span class="o">=</span><span class="n">final_train_set</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict_test_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span><span class="o">=</span><span class="n">final_test_set</span>
                
                

<span class="c1">##########     OPERATIVE PART    ##########</span>
<div class="viewcode-block" id="MultiClass_CP_ILS.generate_ls">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.generate_ls">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_ls</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">latent_dim_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">early_stop_param</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">timer</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This method compute the latent spaces for all the combinations of classes according to the initial selected modality</span>
<span class="sd">            and using as training and testing dataset the specific prepared for each combination.</span>
<span class="sd">            For each combination, a new black box classifier is trained with the sub-selected training samples, then the CP_ILS</span>
<span class="sd">            classical method is called in order to build this specific binary latent space.</span>
<span class="sd">            </span>
<span class="sd">            The results of binary black box, latent space and training values are saved into self.__dict_latent_spaces dict variable.</span>

<span class="sd">            Args:</span>
<span class="sd">                latent_dim_k (int): the dimension K of each generated latent space by default it is equal to 2</span>
<span class="sd">                early_stop_param (int): the condition to avoid to generate too many iterations in case of no improvments, defulat 5 epochs.</span>
<span class="sd">                timer (bool): boolean variable to take note of the time elapsed for training</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">timer</span><span class="p">:</span>
            <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Training latent space for combination: </span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
            <span class="n">class_i</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">class_j</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">label_encoder</span> <span class="o">=</span> <span class="n">LabelEncoder</span><span class="p">()</span>
            <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">sub_ij_test_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_test_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
 
            <span class="n">sub_ij_training_dataset</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">label_encoder</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span>
            <span class="n">sub_ij_test_dataset</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">label_encoder</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sub_ij_test_dataset</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span> 

            <span class="n">binary_bb</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bbox_structure</span><span class="p">)</span>
            <span class="n">binary_bb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="n">latent</span> <span class="o">=</span> <span class="n">cpils</span><span class="o">.</span><span class="n">CP_ILS</span><span class="p">(</span><span class="n">binary_bb</span><span class="o">.</span><span class="n">predict</span><span class="p">,</span> <span class="n">binary_bb</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">,</span> <span class="n">latent_dim</span><span class="o">=</span><span class="n">latent_dim_k</span><span class="p">,</span> <span class="n">early_stopping</span><span class="o">=</span><span class="n">early_stop_param</span><span class="p">)</span>
            <span class="n">losses</span> <span class="o">=</span> <span class="n">latent</span><span class="o">.</span><span class="n">fit</span><span class="p">((</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">sub_ij_test_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__idx_num_cat</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">:</span><span class="n">binary_bb</span><span class="p">,</span> <span class="s2">&quot;label_encoder&quot;</span><span class="p">:</span> <span class="n">label_encoder</span><span class="p">,</span> <span class="s2">&quot;latent&quot;</span><span class="p">:</span><span class="n">latent</span><span class="p">,</span> <span class="s2">&quot;losses&quot;</span><span class="p">:</span> <span class="n">losses</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">timer</span><span class="p">:</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> 
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time needed to train all the latent spaces </span><span class="si">{</span><span class="p">(</span><span class="n">end_time</span><span class="o">-</span><span class="n">start_time</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> sec&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiClass_CP_ILS.generate_counterfactuals">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.generate_counterfactuals">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_counterfactuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">test_instance</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">change_f</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span><span class="n">max_f</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">counter_classes</span><span class="p">:</span><span class="n">Any</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">filtering_mode</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">debug</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Main function to generate counterfactuals for a specific instance. This function should be called after having trained all the latent spaces.</span>
<span class="sd">            Depending on the modality initially chosen, it applies the default generate counterfacutal method on each combination.</span>

<span class="sd">            Args:</span>
<span class="sd">                test_instance (pd.DataFrame): the instance interested in counterfactuals explanations</span>
<span class="sd">                change_f (List[int]): the list of feature that can be modifiable during the procedure of generation</span>
<span class="sd">                max_f (int): it is the maximum number of attribute that can be changed togheter from the change_f list</span>
<span class="sd">                counter_classes (Any): it specify a list of possible classes values interested in generation of counterfactuals or -1 if all available</span>
<span class="sd">                filtering_mode (str): (optionally) it indicate the modality of possible filtering of counterfactuals &#39;acceptable&#39;,&#39;specific&#39;</span>
<span class="sd">                debug (bool): boolean value to print on console debug informations</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                list: a list of counterfactuals grouped by class, cotaining information about all the generated, the predictions of the multi-class and binary classifiers</span>
<span class="sd">                and the filtered ones.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Modality: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1V1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_ALLV1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_ALL_SPECV1</span><span class="p">):</span>
            
            <span class="n">filtering_acceptable</span><span class="o">=</span><span class="s2">&quot;&#39;acceptable&#39; considers any counterfactuals belonging to classes different from the predicted outcome of the Multi-classification black-box model&quot;</span>
            <span class="n">filtering_specific</span><span class="o">=</span><span class="s2">&quot;&#39;specific&#39; considers only counterfactuals belonging to a specific class, different from the predicted outcome of the Multi-classification black-box model&quot;</span>
            
            <span class="k">if</span> <span class="n">filtering_mode</span><span class="o">!=</span><span class="s2">&quot;acceptable&quot;</span> <span class="ow">and</span> <span class="n">filtering_mode</span><span class="o">!=</span><span class="s2">&quot;specific&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filtering_mode can be only &#39;acceptable&#39; or &#39;specific&#39;.</span><span class="se">\n</span><span class="si">{</span><span class="n">filtering_acceptable</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">filtering_specific</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting generation of counterfactuals using filtering_mode: </span><span class="si">{</span><span class="n">filtering_mode</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filtering_acceptable</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">filtering_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;acceptable&#39;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">filtering_specific</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">filtering_mode</span><span class="o">!=</span><span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;In this mode </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="si">}</span><span class="s2"> you cannot specify any filtering method. All the counterfactuals are acceptable.&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting generation of counterfactuals &quot;</span><span class="p">)</span>

        
        <span class="n">statistics</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">y_pred</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_instance</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The predicted class from MBB is </span><span class="si">{</span><span class="n">y_pred</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">counter_classes</span><span class="o">!=-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">y_pred</span> <span class="ow">in</span> <span class="n">counter_classes</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The counter class you want is the same as the predicted class&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1V1</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_counterfactuals_1v1</span><span class="p">(</span><span class="n">test_instance</span><span class="p">,</span><span class="n">change_f</span><span class="p">,</span><span class="n">max_f</span><span class="p">,</span><span class="n">y_pred</span><span class="p">,</span><span class="n">counter_classes</span><span class="p">,</span><span class="n">filtering_mode</span><span class="p">,</span><span class="n">debug</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1VALL</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1VALL_SPEC</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_counterfactuals_1vAll_AllSpec</span><span class="p">(</span><span class="n">test_instance</span><span class="p">,</span><span class="n">change_f</span><span class="p">,</span><span class="n">max_f</span><span class="p">,</span><span class="n">y_pred</span><span class="p">,</span><span class="n">counter_classes</span><span class="p">,</span><span class="n">filtering_mode</span><span class="p">,</span><span class="n">debug</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_ALLV1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_ALL_SPECV1</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generate_counterfactuals_Allv1_Allv1Spec</span><span class="p">(</span><span class="n">test_instance</span><span class="p">,</span><span class="n">change_f</span><span class="p">,</span><span class="n">max_f</span><span class="p">,</span><span class="n">y_pred</span><span class="p">,</span><span class="n">counter_classes</span><span class="p">,</span><span class="n">filtering_mode</span><span class="p">,</span><span class="n">debug</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="kc">None</span></div>


    <span class="k">def</span> <span class="nf">__generate_counterfactuals_1v1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">test_instance</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">change_f</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span><span class="n">max_f</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">y_pred</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">counter_classes</span><span class="p">:</span><span class="n">Any</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">filtering_mode</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">debug</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function should be called after having trained all the latent spaces.</span>
<span class="sd">            It applies the default generate counterfacutal method on each combination and take the counterfacutals that are </span>
<span class="sd">            acceptable and optionally filtering the specifics.</span>

<span class="sd">            Args:</span>
<span class="sd">                test_instance (pd.DataFrame): the instance interested in counterfactuals explanations</span>
<span class="sd">                change_f (List[int]): the list of feature that can be modifiable during the procedure of generation</span>
<span class="sd">                max_f (int): it is the maximum number of attribute that can be changed togheter from the change_f list</span>
<span class="sd">                y_pred (int): the predicted class of the multi-class classifier</span>
<span class="sd">                counter_classes (Any): it specify a list of possible classes values interested in generation of counterfactuals or -1 if all available</span>
<span class="sd">                filtering_mode (str): (optionally) it indicate the modality of possible filtering of counterfactuals &#39;acceptable&#39;,&#39;specific&#39;, default &#39;acceptable&#39;</span>
<span class="sd">                debug (bool): boolean value to print on console debug informations</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                list: a list of counterfactuals grouped by class, cotaining information about all the generated, the predictions of the multi-class and binary classifiers</span>
<span class="sd">                and the filtered ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#Looking in all latent spaces where the class predicted is involved in order to follow the direct direction,</span>
        <span class="c1"># from 1 the specific class to (1, an other specific class). </span>
        <span class="n">list_of_latent_spaces_to_be_considered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_ls_of_class</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span>
        
        <span class="n">statistics</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">list_of_latent_spaces_to_be_considered</span><span class="p">:</span>
            <span class="n">comb</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># here is expected to find a tuple like (1,3)</span>
            <span class="n">latent</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span>
            
            <span class="n">class_of_counterfactual</span><span class="o">=</span> <span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">y_pred</span> <span class="k">else</span> <span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">counter_classes</span><span class="o">==-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">class_of_counterfactual</span> <span class="ow">in</span> <span class="n">counter_classes</span><span class="p">):</span>

                <span class="n">statistics</span><span class="p">[</span><span class="n">class_of_counterfactual</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generation of counterfactual class </span><span class="si">{</span><span class="n">class_of_counterfactual</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">counterfactuals</span><span class="o">=</span><span class="n">latent</span><span class="o">.</span><span class="n">get_counterfactuals</span><span class="p">(</span><span class="n">test_instance</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">change_f</span><span class="p">,</span> <span class="n">max_f</span><span class="p">,</span> <span class="n">max_steps</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_cfs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_feats_sampled</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">topn_to_check</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  

                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">counterfactuals</span><span class="o">.</span><span class="n">empty</span><span class="p">):</span>
                    
                    <span class="n">bbox</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">]</span>
                    
                    <span class="n">y_counter_prediction</span><span class="o">=</span><span class="n">bbox</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>   
                    <span class="n">label_encoder</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;label_encoder&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BBB Encoded y_pred: </span><span class="si">{</span><span class="n">y_counter_prediction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                    <span class="n">y_counter_prediction_decoded</span><span class="o">=</span><span class="n">label_encoder</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_counter_prediction</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BBB Decoded y_pred: </span><span class="si">{</span><span class="n">y_counter_prediction_decoded</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">y_counter_prediction_mbbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                    <span class="c1">#Save all the generated counterfactuals and their predictions indipendently they are correct or not</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">class_of_counterfactual</span><span class="p">][</span><span class="s2">&quot;all_counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">class_of_counterfactual</span><span class="p">][</span><span class="s2">&quot;bbbox_predictions&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">y_counter_prediction_decoded</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">class_of_counterfactual</span><span class="p">][</span><span class="s2">&quot;mbbox_predictions&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">y_counter_prediction_mbbox</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                    <span class="c1">#Discard the countefactuals that fails under binary-classifier: </span>
                    <span class="c1">#this means the methods it self has failed in discovering an acceptable counterfactual</span>
                    <span class="n">indexes_with_diff_label</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_counter_prediction_decoded</span><span class="o">!=</span><span class="n">class_of_counterfactual</span><span class="p">)</span>
                    <span class="n">counterfactuals</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">indexes_with_diff_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 

                    <span class="n">tot_counter_produced_binary</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>
                    
                    <span class="n">y_counter_prediction_mbbox</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="p">,</span> <span class="n">indexes_with_diff_label</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MBB Original y_pred: </span><span class="si">{</span><span class="n">y_counter_prediction_mbbox</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1">#Discard the counterfactuals that fails under multi-class classifier: the class is the same as starting class</span>
                    <span class="n">indexes_with_same_starting_label</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="o">==</span><span class="n">y_pred</span><span class="p">)</span>
                    <span class="n">counterfactuals</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">indexes_with_same_starting_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
                    <span class="n">y_counter_prediction_mbbox</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="p">,</span> <span class="n">indexes_with_same_starting_label</span><span class="p">)</span>

                    <span class="n">tot_counter_acceptable</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;acceptable counterfactuals: </span><span class="si">{</span><span class="n">tot_counter_acceptable</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                    <span class="c1">#Discard all the counterfactuals different from the ORIGINAL class_of_counterfactual designed</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">filtering_mode</span><span class="o">==</span><span class="s2">&quot;specific&quot;</span><span class="p">):</span> 
                        <span class="n">indexes_with_diff_label</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="o">!=</span><span class="n">class_of_counterfactual</span><span class="p">)</span>
                        <span class="n">counterfactuals</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">indexes_with_diff_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">tot_counter_correct</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span> 
                        <span class="k">if</span> <span class="p">(</span><span class="n">tot_counter_correct</span><span class="o">!=</span><span class="n">tot_counter_acceptable</span><span class="p">):</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Discarded counterfactuals: </span><span class="si">{</span><span class="n">tot_counter_acceptable</span><span class="o">-</span><span class="n">tot_counter_correct</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                    <span class="n">statistics</span><span class="p">[</span><span class="n">class_of_counterfactual</span><span class="p">][</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">counterfactuals</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">class_of_counterfactual</span><span class="p">][</span><span class="s2">&quot;all_counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">class_of_counterfactual</span><span class="p">][</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
                    
        <span class="k">return</span> <span class="n">statistics</span>


    <span class="k">def</span> <span class="nf">__generate_counterfactuals_1vAll_AllSpec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">test_instance</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">change_f</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span><span class="n">max_f</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">y_pred</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">counter_classes</span><span class="p">:</span><span class="n">Any</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">filtering_mode</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">debug</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function should be called after having trained all the latent spaces.</span>
<span class="sd">            It applies the default generate counterfacutal method on a specific combination where the y_pred is involved (directly) in</span>
<span class="sd">            the sense of the class y_pred is on the 1 side, instead the others are on the ALL side.</span>
<span class="sd">            This method takes only the counterfacutals that are acceptable.</span>

<span class="sd">            Args:</span>
<span class="sd">                test_instance (pd.DataFrame): the instance interested in counterfactuals explanations</span>
<span class="sd">                change_f (List[int]): the list of feature that can be modifiable during the procedure of generation</span>
<span class="sd">                max_f (int): it is the maximum number of attribute that can be changed togheter from the change_f list</span>
<span class="sd">                y_pred (int): the predicted class of the multi-class classifier</span>
<span class="sd">                counter_classes (Any): it specify a list of possible classes values interested in generation of counterfactuals or -1 if all available</span>
<span class="sd">                filtering_mode: (str): should be &quot;&quot; value because only acceptable counterfactuals are allowed</span>
<span class="sd">                debug (bool): boolean value to print on console debug informations</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                list: a list of counterfactuals grouped by class, cotaining information about all the generated, the predictions of the multi-class and binary classifiers</span>
<span class="sd">                and the filtered ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#Looking in all latent spaces where the class predicted is involved (just 1) in order to follow the direct direction,</span>
        <span class="c1"># from 1 the specific class to All, the opposite classes labels of the predicted one. </span>
        
        <span class="n">list_of_latent_spaces_to_be_considered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_ls_of_class</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span>
        
        <span class="n">statistics</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">list_of_latent_spaces_to_be_considered</span><span class="p">:</span>
            <span class="n">comb</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># here is expected to find a tuple like (1,All)</span>
            <span class="n">latent</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span>
            
            <span class="c1">#**CONVENTION** --&gt; remember init the class of &quot;1&quot; side has value 0</span>
            <span class="n">class_of_counterfactual</span><span class="o">=</span><span class="mi">1</span>
            
            <span class="n">statistics</span><span class="p">[</span><span class="s2">&quot;All&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generation of counterfactual class ALL&quot;</span><span class="p">)</span>
            
            <span class="n">counterfactuals</span><span class="o">=</span><span class="n">latent</span><span class="o">.</span><span class="n">get_counterfactuals</span><span class="p">(</span><span class="n">test_instance</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">change_f</span><span class="p">,</span> <span class="n">max_f</span><span class="p">,</span> <span class="n">max_steps</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_cfs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_feats_sampled</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">topn_to_check</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
            
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">counterfactuals</span><span class="o">.</span><span class="n">empty</span><span class="p">):</span>
                    
                <span class="n">bbox</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">]</span>
                        
                <span class="n">y_counter_prediction</span><span class="o">=</span><span class="n">bbox</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>   
                <span class="n">label_encoder</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;label_encoder&quot;</span><span class="p">]</span>
                
                <span class="n">y_counter_prediction_decoded</span><span class="o">=</span><span class="n">label_encoder</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_counter_prediction</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BBB Decoded y_pred: </span><span class="si">{</span><span class="n">y_counter_prediction_decoded</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BBB 1 means binary correctly classified&quot;</span><span class="p">)</span>
                <span class="n">y_counter_prediction_mbbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1">#Save all the generated counterfactuals and their predictions indipendently they are correct or not</span>
                <span class="n">statistics</span><span class="p">[</span><span class="s2">&quot;All&quot;</span><span class="p">][</span><span class="s2">&quot;all_counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">statistics</span><span class="p">[</span><span class="s2">&quot;All&quot;</span><span class="p">][</span><span class="s2">&quot;bbbox_predictions&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">y_counter_prediction_decoded</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">statistics</span><span class="p">[</span><span class="s2">&quot;All&quot;</span><span class="p">][</span><span class="s2">&quot;mbbox_predictions&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">y_counter_prediction_mbbox</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1">#Discard the countefactuals that fails under binary classifier</span>
                <span class="n">indexes_with_diff_label</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_counter_prediction_decoded</span><span class="o">!=</span><span class="n">class_of_counterfactual</span><span class="p">)</span>

                <span class="n">counterfactuals</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">indexes_with_diff_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
                
                <span class="n">tot_counter_produced_binary</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>
                
                <span class="n">y_counter_prediction_mbbox</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="p">,</span> <span class="n">indexes_with_diff_label</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MBB Original y_pred: </span><span class="si">{</span><span class="n">y_counter_prediction_mbbox</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#Discard the counterfactuals that fails under multi-class classifier: the class is the same as starting class</span>
                <span class="n">indexes_with_same_starting_label</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="o">==</span><span class="n">y_pred</span><span class="p">)</span>
                <span class="n">counterfactuals</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">indexes_with_same_starting_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
                <span class="n">y_counter_prediction_mbbox</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="p">,</span> <span class="n">indexes_with_same_starting_label</span><span class="p">)</span>

                <span class="n">tot_counter_acceptable</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;acceptable counterfactuals: </span><span class="si">{</span><span class="n">tot_counter_acceptable</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1">#If counter_classes is specified filter only the classes indicated</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">counter_classes</span><span class="o">!=-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering counterfactuals of classes: </span><span class="si">{</span><span class="n">counter_classes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">indexes_with_diff_label</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="p">,</span> <span class="n">counter_classes</span><span class="p">))</span>
                    <span class="n">counterfactuals</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">indexes_with_diff_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">tot_counter_correct</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">tot_counter_correct</span><span class="o">!=</span><span class="n">tot_counter_acceptable</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Discarded counterfactuals: </span><span class="si">{</span><span class="n">tot_counter_acceptable</span><span class="o">-</span><span class="n">tot_counter_correct</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">statistics</span><span class="p">[</span><span class="s2">&quot;All&quot;</span><span class="p">][</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">counterfactuals</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="n">statistics</span><span class="p">[</span><span class="s2">&quot;All&quot;</span><span class="p">][</span><span class="s2">&quot;all_counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
                <span class="n">statistics</span><span class="p">[</span><span class="s2">&quot;All&quot;</span><span class="p">][</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
                
        <span class="k">return</span> <span class="n">statistics</span>

    <span class="k">def</span> <span class="nf">__generate_counterfactuals_Allv1_Allv1Spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">test_instance</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">change_f</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span><span class="n">max_f</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">y_pred</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span><span class="n">counter_classes</span><span class="p">:</span><span class="n">Any</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">filtering_mode</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">debug</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function should be called after having trained all the latent spaces.</span>
<span class="sd">            It applies the default generate counterfacutal method on each combination and take the counterfacutals that are </span>
<span class="sd">            acceptable and optionally filtering the specifics. </span>
<span class="sd">            It applies the default generate counterfacutal method on all the combinations where the y_pred is involved (indirectly) in</span>
<span class="sd">            the sense of the class y_pred is on the ALL side, instead the others are on the 1 side.</span>
<span class="sd">            </span>

<span class="sd">            Args:</span>
<span class="sd">                test_instance (pd.DataFrame): the instance interested in counterfactuals explanations</span>
<span class="sd">                change_f (List[int]): the list of feature that can be modifiable during the procedure of generation</span>
<span class="sd">                max_f (int): it is the maximum number of attribute that can be changed togheter from the change_f list</span>
<span class="sd">                y_pred (int): the predicted class of the multi-class classifier</span>
<span class="sd">                counter_classes (Any): it specify a list of possible classes values interested in generation of counterfactuals</span>
<span class="sd">                filtering_mode (str): (optionally) it indicate the modality of possible filtering of counterfactuals &#39;acceptable&#39;,&#39;specific&#39;,default &#39;acceptable&#39;</span>
<span class="sd">                debug (bool): boolean value to print on console debug informations</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                list: a list of counterfactuals grouped by class, cotaining information about all the generated, the predictions of the multi-class and binary classifiers</span>
<span class="sd">                and the filtered ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1">#Looking in all latent spaces where the class predicted is involved in order to follow the opposite direction,</span>
        <span class="c1">#from ALL (where y_pred also belong to 1 a specific_class who the counterfactuals is desidered.</span>
    
        <span class="n">list_of_latent_spaces_to_be_considered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_ls_of_not_class</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span>

        <span class="n">statistics</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">list_of_latent_spaces_to_be_considered</span><span class="p">:</span>
            <span class="n">comb</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># class_vs_all</span>
            <span class="n">comb_first_elem</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#e.g. 1</span>
            <span class="n">latent</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span>

            <span class="c1">#**CONVENTION** --&gt; remember init the class of &quot;1&quot; side has value 0</span>
            <span class="n">class_of_counterfactual</span><span class="o">=</span><span class="mi">0</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">counter_classes</span><span class="o">==-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">comb_first_elem</span> <span class="ow">in</span> <span class="n">counter_classes</span><span class="p">):</span>

                <span class="n">statistics</span><span class="p">[</span><span class="n">comb_first_elem</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generation of counterfactual class </span><span class="si">{</span><span class="n">comb_first_elem</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">counterfactuals</span><span class="o">=</span><span class="n">latent</span><span class="o">.</span><span class="n">get_counterfactuals</span><span class="p">(</span><span class="n">test_instance</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">change_f</span><span class="p">,</span> <span class="n">max_f</span><span class="p">,</span> <span class="n">max_steps</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_cfs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_feats_sampled</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">topn_to_check</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
    
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">counterfactuals</span><span class="o">.</span><span class="n">empty</span><span class="p">):</span>
    
                    <span class="n">bbox</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">]</span>
                    <span class="n">y_counter_prediction</span><span class="o">=</span><span class="n">bbox</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>   
                    <span class="n">label_encoder</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;label_encoder&quot;</span><span class="p">]</span>
                    
                    <span class="n">y_counter_prediction_decoded</span><span class="o">=</span><span class="n">label_encoder</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_counter_prediction</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BBB Decoded y_pred: </span><span class="si">{</span><span class="n">y_counter_prediction_decoded</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    
                    <span class="n">y_counter_prediction_mbbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                    <span class="c1">#Save all the generated counterfactuals and their predictions indipendently they are correct or not</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">comb_first_elem</span><span class="p">][</span><span class="s2">&quot;all_counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">comb_first_elem</span><span class="p">][</span><span class="s2">&quot;bbbox_predictions&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">y_counter_prediction_decoded</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">comb_first_elem</span><span class="p">][</span><span class="s2">&quot;mbbox_predictions&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">y_counter_prediction_mbbox</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
                    <span class="c1">#Discard the countefactuals that fails under binary classifier</span>
                    <span class="n">indexes_with_diff_label</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_counter_prediction_decoded</span><span class="o">!=</span><span class="n">class_of_counterfactual</span><span class="p">)</span>
                    <span class="n">counterfactuals</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">indexes_with_diff_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        
                    <span class="n">tot_counter_produced_binary</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>
        
                    <span class="n">y_counter_prediction_mbbox</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="p">,</span> <span class="n">indexes_with_diff_label</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MBB Original y_pred: </span><span class="si">{</span><span class="n">y_counter_prediction_mbbox</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
                    <span class="c1">#Discard the counterfactuals that fails under multi-class classifier: the class is the same as starting class</span>
                    <span class="n">indexes_with_same_starting_label</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="o">==</span><span class="n">y_pred</span><span class="p">)</span>
                    <span class="n">counterfactuals</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">indexes_with_same_starting_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
                    <span class="n">y_counter_prediction_mbbox</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="p">,</span> <span class="n">indexes_with_same_starting_label</span><span class="p">)</span>
        
                    <span class="n">tot_counter_acceptable</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;acceptable counterfactuals: </span><span class="si">{</span><span class="n">tot_counter_acceptable</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
                    <span class="c1">#Discard all the counterfactuals different from the ORIGINAL class_of_counterfactual designed</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">filtering_mode</span><span class="o">==</span><span class="s2">&quot;specific&quot;</span><span class="p">):</span> 
                        <span class="n">indexes_with_diff_label</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_counter_prediction_mbbox</span><span class="o">!=</span><span class="n">comb_first_elem</span><span class="p">)</span>
                        <span class="n">counterfactuals</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">counterfactuals</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">indexes_with_diff_label</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">tot_counter_correct</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">counterfactuals</span><span class="p">)</span> 
                        <span class="k">if</span> <span class="p">(</span><span class="n">tot_counter_correct</span><span class="o">!=</span><span class="n">tot_counter_acceptable</span><span class="p">):</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">debug</span><span class="p">):</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Discarded counterfactuals: </span><span class="si">{</span><span class="n">tot_counter_acceptable</span><span class="o">-</span><span class="n">tot_counter_correct</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                                
        
                    <span class="n">statistics</span><span class="p">[</span><span class="n">comb_first_elem</span><span class="p">][</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">counterfactuals</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">comb_first_elem</span><span class="p">][</span><span class="s2">&quot;all_counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
                    <span class="n">statistics</span><span class="p">[</span><span class="n">comb_first_elem</span><span class="p">][</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">return</span> <span class="n">statistics</span>

    
    
<div class="viewcode-block" id="MultiClass_CP_ILS.execute_ranking_of_counterfactuals">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.execute_ranking_of_counterfactuals">[docs]</a>
    <span class="k">def</span> <span class="nf">execute_ranking_of_counterfactuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_instance</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">df_counterfactuals</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">ranking</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;proximity&quot;</span><span class="p">,</span> <span class="n">group_by_class</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">top_k</span><span class="p">:</span><span class="nb">int</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function is used for ranking a list of counterfactuals related to a target test instance.</span>
<span class="sd">            It gives the possibility to rank counterfactuals per proximity or per probability class prediction.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                test_instance (pd.DataFrame): the instance related to the counterfactuals list, used to determine proximity</span>
<span class="sd">                df_counterfactuals (pd.DataFrame): the list of counterfactuals that needs to be ranked</span>
<span class="sd">                ranking (str): the modality of ranking; proximity-&gt; use the distance between the counters and the test_instance, </span>
<span class="sd">                         accuracy pushes up the counterfactuals with higher prediction probability, default proximity</span>
<span class="sd">                group_by_class (bool): specifies if the results are presented ranked per class or not, default True</span>
<span class="sd">                top_k (int): specifies the number of counterfactulas to show at maximum in the final view</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                list: It return a list of ranked counterfactuals accordingly to specified criterion.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span><span class="o">=</span><span class="p">{}</span>

        <span class="c1">#Determine the probability prediction and proximity distance</span>
        <span class="n">probab</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">df_counterfactuals</span><span class="p">)</span>
        <span class="n">classes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">probab</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">max_prob</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">probab</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">distances</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cdist_sample_distance</span><span class="p">(</span><span class="n">test_instance</span><span class="p">,</span><span class="n">df_counterfactuals</span><span class="p">)</span>
        
        <span class="c1">#print (probab)</span>
        <span class="c1">#print (classes)</span>
        <span class="c1">#print (max_prob)</span>
        
        <span class="n">df_counterfactuals</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">classes</span>
        <span class="n">df_counterfactuals</span><span class="p">[</span><span class="s2">&quot;prob&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">max_prob</span>
        <span class="n">df_counterfactuals</span><span class="p">[</span><span class="s2">&quot;dist&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        
        <span class="k">if</span> <span class="p">(</span><span class="n">ranking</span><span class="o">==</span><span class="s2">&quot;accuracy&quot;</span><span class="p">):</span>
            <span class="n">sorted_counterfactuals</span><span class="o">=</span><span class="n">df_counterfactuals</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;prob&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ranking</span><span class="o">==</span><span class="s2">&quot;proximity&quot;</span><span class="p">):</span>
            <span class="n">sorted_counterfactuals</span><span class="o">=</span><span class="n">df_counterfactuals</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;dist&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1">#If group the results by class or not</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">group_by_class</span><span class="p">):</span>
            <span class="n">counter_classes</span><span class="o">=</span><span class="n">sorted_counterfactuals</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">counter_classes</span> <span class="ow">in</span> <span class="n">counter_classes</span><span class="p">:</span>
                <span class="n">ris</span><span class="o">=</span><span class="p">{}</span>
                <span class="n">select_counterfactuals</span><span class="o">=</span><span class="n">sorted_counterfactuals</span><span class="p">[</span><span class="n">sorted_counterfactuals</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">==</span><span class="n">counter_classes</span><span class="p">]</span>
                
                <span class="c1">#Take the top_k ordered instances per class</span>
                <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">select_counterfactuals</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">top_k</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">top_k</span><span class="o">!=-</span><span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">select_counterfactuals</span>
                <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;prob&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">][</span><span class="s2">&quot;prob&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;dist&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">][</span><span class="s2">&quot;dist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">,</span><span class="s2">&quot;prob&quot;</span><span class="p">,</span><span class="s2">&quot;dist&quot;</span><span class="p">],</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">counter_classes</span><span class="p">]</span><span class="o">=</span><span class="n">ris</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ris</span><span class="o">=</span><span class="p">{}</span>
            <span class="c1">#Take the top_k ordered instances among all</span>
            <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">sorted_counterfactuals</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">top_k</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">top_k</span><span class="o">!=-</span><span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">sorted_counterfactuals</span>
            <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">][</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;prob&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">][</span><span class="s2">&quot;prob&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;dist&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">][</span><span class="s2">&quot;dist&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            
            <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">,</span><span class="s2">&quot;prob&quot;</span><span class="p">,</span><span class="s2">&quot;dist&quot;</span><span class="p">],</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="s2">&quot;counterfactuals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">results</span><span class="o">=</span><span class="n">ris</span> 
            
        <span class="k">return</span> <span class="n">results</span></div>



<div class="viewcode-block" id="MultiClass_CP_ILS.cdist_sample_distance">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.cdist_sample_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">cdist_sample_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XA</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">XB</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;jaccard&#39;</span><span class="p">),</span> <span class="n">w</span><span class="p">:</span><span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The distance function used to measure the distance among to 2 distinct samples; the same used in original paper</span>
<span class="sd">            combining Hamming distance for categorical values and cosine distance for continous attribute.</span>
<span class="sd">            This method can be applied simultaneously to multiple points at time, returing a matrix of distances.</span>

<span class="sd">            Args:</span>
<span class="sd">                XA (pd.DataFrame): representing the first sample instance, can be used with multiple rows</span>
<span class="sd">                XB (pd.DataFrame): representing the second sample instance can be used with multiple rows</span>
<span class="sd">                metric (str): this is the criterion used for continuous and categorical variables</span>
<span class="sd">                w (Any): The weight vector for metrics that support weights (e.g., Minkowski)</span>

<span class="sd">            Returns:</span>
<span class="sd">                numpy.array: a numerical array of distances accordingly to metric between XA and XB </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metric_continuous</span> <span class="o">=</span> <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">metric_categorical</span> <span class="o">=</span> <span class="n">metric</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_cat</span><span class="p">:</span>
            <span class="n">dist_categorical</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_cat</span><span class="p">],</span> <span class="n">XB</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_cat</span><span class="p">],</span>
                                 <span class="n">metric</span><span class="o">=</span><span class="n">metric_categorical</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
            <span class="c1">#self.__train_set.shape[1]-1 = is the input_dim-1 of original dataset</span>
            <span class="n">ratio_categorical</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_cat</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">ratio_categorical</span> <span class="o">*</span> <span class="n">dist_categorical</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_num</span><span class="p">:</span>
                <span class="n">dist_continuous</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_num</span><span class="p">],</span> <span class="n">XB</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_num</span><span class="p">],</span>
                                    <span class="n">metric</span><span class="o">=</span><span class="n">metric_continuous</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
                <span class="c1">#self.__train_set.shape[1]-1 = is the input_dim-1 of original dataset</span>
                <span class="n">ratio_continuous</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_num</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__train_set</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">dist</span> <span class="o">+=</span> <span class="n">ratio_continuous</span> <span class="o">*</span> <span class="n">dist_continuous</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="p">,</span> <span class="n">XB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric_continuous</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dist</span></div>



<span class="c1">##########     PLOTTING PART    ##########</span>


    <span class="k">def</span> <span class="nf">__plot_ls_directions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">latent</span><span class="p">:</span><span class="n">Any</span><span class="p">,</span><span class="n">X_instances</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">title</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function to plot the latent space counterfactuals directions</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                latent (Any): the latent space involved</span>
<span class="sd">                X_instances (pd.DataFrame): the original instances to be transformed and then projected in 2D space</span>
<span class="sd">                title (str): the title of the plot</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">W_train</span><span class="p">,</span> <span class="n">Z_train</span> <span class="o">=</span> <span class="n">latent</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_instances</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Z_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="mi">2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The dimension of that latent space is greater then 2. The graph can not be plotted.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Z_train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Z_train</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">latent</span><span class="o">.</span><span class="n">y_train_bb</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">Z_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">100</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">W_train</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">y_contrib</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">latent</span><span class="o">.</span><span class="n">y_train_bb</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.5</span><span class="p">:</span>
                <span class="n">y_contrib</span> <span class="o">*=-</span><span class="mi">1</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">Z_train</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Z_train</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">y_contrib</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_contrib</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__plot_ls_class_scatter_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Z_train</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">Y_labels</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">title</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">target</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;classes_MBB&quot;</span><span class="p">,</span><span class="n">comb</span><span class="p">:</span><span class="nb">tuple</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">,</span><span class="s2">&quot;All&quot;</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function to plot a scatter plot of specific points</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                Z_train (pd.DataFrame): the latent space samples involved</span>
<span class="sd">                Y_labels (np.ndarray): the original class values associated</span>
<span class="sd">                title (str): the title of the plot</span>
<span class="sd">                target (str): if it is involved the multi-class classifier or not classes_MBB (by default)</span>
<span class="sd">                comb (tuple): the specific combination involved in the plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Z_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="mi">2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The dimension of that latent space is greater then 2. The graph can not be plotted.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
            
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Y_labels</span><span class="p">):</span>
            <span class="n">class_name</span><span class="o">=</span><span class="n">label</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1V1</span> <span class="ow">and</span> <span class="n">target</span><span class="o">!=</span><span class="s2">&quot;classes_MBB&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">label</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">class_name</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">class_name</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Z_train</span><span class="p">[</span><span class="n">Y_labels</span><span class="o">==</span><span class="n">label</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Z_train</span><span class="p">[</span><span class="n">Y_labels</span><span class="o">==</span><span class="n">label</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__hex_colors_for_classes</span><span class="p">[</span><span class="n">label</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Class </span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Classes&quot;</span><span class="p">)</span>
    
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__prepare_ls_class_scatter_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ax</span><span class="p">:</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">Axes</span><span class="p">,</span><span class="n">Z_train</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">Y_labels</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">title</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">comb</span><span class="p">:</span><span class="nb">tuple</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">,</span><span class="s2">&quot;All&quot;</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function to produce a scatter plot to be used later in specific graph.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                ax (matplotlib.axes.Axes): the variable involved in the plot</span>
<span class="sd">                Z_train (pd.DataFrame): the latent space samples involved</span>
<span class="sd">                Y_labels (np.ndarray): the original class values associated</span>
<span class="sd">                title (str): the title of the plot</span>
<span class="sd">                comb (tuple): the specific combination involved in the plot</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                ax (matplotlib.axes.Axes): the updated variable with scatter plot</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Z_train</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="mi">2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The dimension of that latent space is greater then 2. The graph can not be plotted.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">Y_labels</span><span class="p">):</span>
            <span class="n">class_name</span><span class="o">=</span><span class="n">label</span>
            <span class="n">label_color</span><span class="o">=</span><span class="n">label</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mode</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">MODE_1V1</span> <span class="ow">and</span> <span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;None&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">label</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                    <span class="n">class_name</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">label_color</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">class_name</span><span class="o">=</span><span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">label_color</span><span class="o">=</span><span class="n">value</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hex_colors_for_classes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">Z_train</span><span class="p">[</span><span class="n">Y_labels</span><span class="o">==</span><span class="n">label</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Z_train</span><span class="p">[</span><span class="n">Y_labels</span><span class="o">==</span><span class="n">label</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__hex_colors_for_classes</span><span class="p">[</span><span class="n">label_color</span><span class="p">],</span><span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Class </span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">&quot;Classes&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">ax</span>
                            
    <span class="k">def</span> <span class="nf">__plot_ls_losses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">losses</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span><span class="n">title</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function to plot the curves of training and validation losses during generation of latent spaces.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                losses (list): the list of points to be visualized</span>
<span class="sd">                title (str): the title of the plot</span>
<span class="sd">            Displays:</span>
<span class="sd">                A plot showing the training and validation loss curves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">losses</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;train&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">losses</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;epochs&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;loss&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            
<div class="viewcode-block" id="MultiClass_CP_ILS.plot_ls_comb">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.plot_ls_comb">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_ls_comb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">target</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span><span class="n">comb</span><span class="p">:</span><span class="nb">tuple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">class_name</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            </span>
<span class="sd">            Function callable from outside to plot a scatter plot of specific combination or class.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                target (str): must specify the type of plot only possibles directions,classes_BBB or classes_MBB</span>
<span class="sd">                comb (tuple): the specific combination involved in the plot</span>
<span class="sd">                class_name (str): the specific class involved in the combinatio to be plotted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">target_allowed</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;directions&quot;</span><span class="p">,</span><span class="s2">&quot;classes_BBB&quot;</span><span class="p">,</span><span class="s2">&quot;classes_MBB&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target_allowed</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target selected </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2"> is not allowed, please select &#39;directions&#39; or &#39;classes&#39;&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">comb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2"> is not a valid combination. Please select one from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">class_name</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s2"> is not a valid class name. Please select one from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>
            
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">==</span><span class="s2">&quot;directions&quot;</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">==</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">latent_space_comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">:</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Plot of latent space of combination </span><span class="si">{</span><span class="n">latent_space_comb</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__plot_ls_directions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">],</span><span class="n">sub_ij_training_dataset</span><span class="p">,</span><span class="n">title</span><span class="p">)</span>   
            
            <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="p">):</span>
                <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span>
                
                <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Plot of latent space of combination </span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__plot_ls_directions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">comb</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">],</span><span class="n">sub_ij_training_dataset</span><span class="p">,</span><span class="n">title</span><span class="p">)</span> 
                <span class="k">return</span>   
                    
            <span class="k">if</span> <span class="p">(</span><span class="n">class_name</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">latent_space_comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ls_of_class</span><span class="p">(</span><span class="n">class_name</span><span class="p">):</span>
                    
                    <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Plot of latent space of combination </span><span class="si">{</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__plot_ls_directions</span><span class="p">(</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">],</span><span class="n">sub_ij_training_dataset</span><span class="p">,</span><span class="n">title</span><span class="p">)</span>
                

        <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">==</span><span class="s2">&quot;classes_BBB&quot;</span> <span class="ow">or</span> <span class="n">target</span><span class="o">==</span><span class="s2">&quot;classes_MBB&quot;</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">==</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">latent_space_comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">:</span>

                    <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Plot of latent space of combination </span><span class="si">{</span><span class="n">latent_space_comb</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">]</span>

                    <span class="n">_</span><span class="p">,</span> <span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">==</span><span class="s2">&quot;classes_MBB&quot;</span><span class="p">):</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="o">+</span><span class="s2">&quot; -- MBB Multi-classification Black Box&quot;</span>
                        <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="o">+</span><span class="s2">&quot; -- BBB Binary-classification Black Box&quot;</span>
                        <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">][</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">][</span><span class="s2">&quot;label_encoder&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_values</span><span class="p">)</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">__plot_ls_class_scatter_plot</span><span class="p">(</span><span class="n">Z_train</span><span class="p">,</span><span class="n">y_values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span><span class="n">title</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">latent_space_comb</span><span class="p">)</span>   
            
            <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="p">):</span>

                <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Plot of latent space of combination </span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2">&quot;</span>
                
                <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">comb</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">==</span><span class="s2">&quot;classes_MBB&quot;</span><span class="p">):</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="o">+</span><span class="s2">&quot; -- MBB Multi-classification Black Box&quot;</span>
                        <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="o">+</span><span class="s2">&quot; -- BBB Binary-classification Black Box&quot;</span>
                        <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">comb</span><span class="p">][</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">comb</span><span class="p">][</span><span class="s2">&quot;label_encoder&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_values</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">__plot_ls_class_scatter_plot</span><span class="p">(</span><span class="n">Z_train</span><span class="p">,</span><span class="n">y_values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span><span class="n">title</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">comb</span><span class="p">)</span>   
                <span class="k">return</span>
                    
            <span class="k">if</span> <span class="p">(</span><span class="n">class_name</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">):</span>
                
                <span class="k">for</span> <span class="n">latent_space_comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ls_of_class</span><span class="p">(</span><span class="n">class_name</span><span class="p">):</span>
                    
                    <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Plot of latent space of combination </span><span class="si">{</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                    <span class="n">_</span><span class="p">,</span> <span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">==</span><span class="s2">&quot;classes_MBB&quot;</span><span class="p">):</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="o">+</span><span class="s2">&quot; -- MBB Multi-classification Black Box&quot;</span>
                        <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="o">+</span><span class="s2">&quot; -- BBB Binary-classification Black Box&quot;</span>
                        <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;label_encoder&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_values</span><span class="p">)</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">__plot_ls_class_scatter_plot</span><span class="p">(</span><span class="n">Z_train</span><span class="p">,</span><span class="n">y_values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span><span class="n">title</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>    </div>

    
<div class="viewcode-block" id="MultiClass_CP_ILS.plot_ls_comb_compare">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.plot_ls_comb_compare">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_ls_comb_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">comb</span><span class="p">:</span><span class="nb">tuple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">class_name</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function callable from outside to plot a comparison of scatter plots (multi-class and binary) for specific combination or class.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                comb (tuple): the specific combination involved in the plot</span>
<span class="sd">                class_name (str): the specific class involved in the combinatio to be plotted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">comb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2"> is not a valid combination. Please select one from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">class_name</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">class_name</span><span class="si">}</span><span class="s2"> is not a valid class name. Please select one from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>


        <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">==</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">latent_space_comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">:</span>
                
                <span class="c1"># Create two subplots, side by side (1 row, 2 columns)</span>
                <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    
                <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">]</span>
    
                <span class="n">_</span><span class="p">,</span> <span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    
                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;MBB Multi-classification Black Box&quot;</span>
                <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                
                <span class="n">ax1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__prepare_ls_class_scatter_plot</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">Z_train</span><span class="p">,</span><span class="n">y_values</span><span class="p">,</span><span class="n">title</span><span class="p">)</span>
    
                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;BBB Binary-classification Black Box&quot;</span>
                <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">][</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">][</span><span class="s2">&quot;label_encoder&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_values</span><span class="p">)</span>
                
                <span class="n">ax2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__prepare_ls_class_scatter_plot</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span><span class="n">Z_train</span><span class="p">,</span><span class="n">y_values</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">latent_space_comb</span><span class="p">)</span>
                
                <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plot of latent space of combination </span><span class="si">{</span><span class="n">latent_space_comb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">rect</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="p">):</span>

            <span class="c1"># Create two subplots, side by side (1 row, 2 columns)</span>
            <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                 
            <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">comb</span><span class="p">][</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="n">title</span><span class="o">=</span><span class="s2">&quot;MBB Multi-classification Black Box&quot;</span>
            <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="n">ax1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__prepare_ls_class_scatter_plot</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">Z_train</span><span class="p">,</span><span class="n">y_values</span><span class="p">,</span><span class="n">title</span><span class="p">)</span>
        
            <span class="n">title</span><span class="o">=</span><span class="s2">&quot;BBB Binary-classification Black Box&quot;</span>
            <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">comb</span><span class="p">][</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">comb</span><span class="p">][</span><span class="s2">&quot;label_encoder&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_values</span><span class="p">)</span>
            
            <span class="n">ax2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__prepare_ls_class_scatter_plot</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span><span class="n">Z_train</span><span class="p">,</span><span class="n">y_values</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">comb</span><span class="p">)</span>

            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plot of latent space of combination </span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">rect</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                
            <span class="k">return</span>
            
        <span class="k">if</span> <span class="p">(</span><span class="n">class_name</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">):</span>
                
            <span class="k">for</span> <span class="n">latent_space_comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ls_of_class</span><span class="p">(</span><span class="n">class_name</span><span class="p">):</span>

                <span class="c1"># Create two subplots, side by side (1 row, 2 columns)</span>
                <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                
                <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">Z_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;latent&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;MBB Multi-classification Black Box&quot;</span>
                <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ax1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__prepare_ls_class_scatter_plot</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">Z_train</span><span class="p">,</span><span class="n">y_values</span><span class="p">,</span><span class="n">title</span><span class="p">)</span>

                <span class="n">title</span><span class="o">=</span><span class="s2">&quot;BBB Binary-classification Black Box&quot;</span>
                <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;binary_bbox&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sub_ij_training_dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">y_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;label_encoder&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">y_values</span><span class="p">)</span>
                <span class="n">ax2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__prepare_ls_class_scatter_plot</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span><span class="n">Z_train</span><span class="p">,</span><span class="n">y_values</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                
                <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plot of latent space of combination </span><span class="si">{</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">rect</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="MultiClass_CP_ILS.plot_ls_training_losses">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.plot_ls_training_losses">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_ls_training_losses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">comb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">class_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Function callable from outside to plot the curves of training and validation losses during generation of latent spaces.</span>
<span class="sd">    </span>
<span class="sd">            Args:</span>
<span class="sd">                comb: the specific combination involved in the plot</span>
<span class="sd">                class_name: the specific class involved in the combinatio to be plotted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">==</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span><span class="o">==</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">latent_space_comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Plot training loss of latent space of combination </span><span class="si">{</span><span class="n">latent_space_comb</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__plot_ls_losses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">][</span><span class="s2">&quot;losses&quot;</span><span class="p">],</span><span class="n">title</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="p">(</span><span class="n">comb</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class_combinations</span><span class="p">):</span>
            <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span>
            <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Plot training loss of latent space of combination </span><span class="si">{</span><span class="n">comb</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__plot_ls_losses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_latent_spaces</span><span class="p">[</span><span class="n">comb</span><span class="p">][</span><span class="s2">&quot;losses&quot;</span><span class="p">],</span><span class="n">title</span><span class="p">)</span>
            <span class="k">return</span>
                
        <span class="k">if</span> <span class="p">(</span><span class="n">class_name</span><span class="o">!=</span><span class="kc">None</span> <span class="ow">and</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__all_classes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">latent_space_comb</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ls_of_class</span><span class="p">(</span><span class="n">class_name</span><span class="p">):</span>
                <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Plot training loss of latent space of combination </span><span class="si">{</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">sub_ij_training_dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict_train_datasets</span><span class="p">[</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__plot_ls_losses</span><span class="p">(</span><span class="n">latent_space_comb</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;losses&quot;</span><span class="p">],</span><span class="n">title</span><span class="p">)</span></div>


    
<div class="viewcode-block" id="MultiClass_CP_ILS.execute_testing_on_data">
<a class="viewcode-back" href="../MultiClass_CPILS.html#MultiClass_CPILS.MultiClass_CP_ILS.execute_testing_on_data">[docs]</a>
    <span class="k">def</span> <span class="nf">execute_testing_on_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">test_name</span><span class="p">,</span><span class="n">test_instances</span><span class="p">,</span><span class="n">change_f</span><span class="p">,</span><span class="n">max_f</span><span class="p">,</span><span class="n">filtering_mode</span><span class="o">=</span><span class="s2">&quot;acceptable&quot;</span><span class="p">,</span><span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This function call iteratively the methods to generate the counterfactuals and save all the results on external files</span>
<span class="sd">            specified by input parameters, in order to make a post-hoc analyis of the goodness of used methods.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                test_name: the name to be used as suffix in the generation of the files</span>
<span class="sd">                test_instances: the list of instances involved during the test of the methods</span>
<span class="sd">                change_f: the list of feature that can be modifiable during the procedure of generation</span>
<span class="sd">                max_f: it is the maximum number of attribute that can be changed togheter from the change_f list</span>
<span class="sd">                filtering_mode: (optionally) it indicate the modality of possible filtering of counterfactuals &#39;acceptable&#39;,&#39;specific&#39;,default &#39;acceptable&#39;</span>
<span class="sd">                debug: boolean value to print on console debug informations</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the directory tests if it doesn&#39;t exist</span>
        <span class="n">dir_name</span> <span class="o">=</span> <span class="s2">&quot;tests&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dir_name</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dir_name</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Directory &#39;</span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">&#39; created.&quot;</span><span class="p">)</span>

        <span class="c1">#Create FILE1 new source of test_set with instance id</span>
        <span class="n">ts</span><span class="o">=</span><span class="n">test_instances</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ts</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ID_TEST&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;./&quot;</span><span class="o">+</span><span class="n">dir_name</span><span class="o">+</span><span class="s2">&quot;/testset_&quot;</span><span class="o">+</span><span class="n">test_name</span><span class="o">+</span><span class="s2">&quot;.csv&quot;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">#Create FILE2 intermediary informations about test_instance and its counterfactuals</span>
        <span class="n">index_position</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ID_TEST&#39;</span><span class="p">,</span><span class="s1">&#39;orig_test_class&#39;</span><span class="p">,</span><span class="s1">&#39;mbbox_test_class_pred&#39;</span><span class="p">,</span><span class="s1">&#39;counter_class_desired&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;ID_COUNTER&#39;</span><span class="p">,</span><span class="s1">&#39;bbbox_counter_class_pred&#39;</span><span class="p">,</span><span class="s1">&#39;mbbox_counter_class_pred&#39;</span><span class="p">,</span><span class="s1">&#39;mmbox_counter_class_prob&#39;</span><span class="p">,</span><span class="s1">&#39;counter_distance&#39;</span><span class="p">])</span>

        <span class="c1">#Create FILE3 new counterfactuals_set with id: THIRD FILE</span>
        <span class="n">id_counterfactual</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">df_counterfactuals</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1">#SECOND COLUMN -- info related to the original class</span>
        <span class="n">y_labels</span><span class="o">=</span><span class="n">test_instances</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1">#THIRD COLUMN -- info related to the prediction of mbbox of original instance</span>
        <span class="n">y_mbbox_predictions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_instances</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
       
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing test instances&quot;</span><span class="p">):</span>
            
            <span class="c1">#index used to get the exact test_instance</span>
            <span class="n">test_instance</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>
            
            <span class="n">test_instance_id</span><span class="o">=</span><span class="n">ts</span><span class="p">[</span><span class="s2">&quot;ID_TEST&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

            <span class="n">ris</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generate_counterfactuals</span><span class="p">(</span><span class="n">test_instance</span><span class="p">,</span><span class="n">change_f</span><span class="p">,</span><span class="n">max_f</span><span class="p">,</span><span class="n">counter_classes</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">filtering_mode</span><span class="o">=</span><span class="n">filtering_mode</span><span class="p">,</span><span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">ris</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1">#FOURTH COLUMN: label used to get the desired class of the counterfactual</span>
                <span class="n">counter_class_desired</span><span class="o">=</span><span class="n">label</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">ris</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s2">&quot;all_counterfactuals&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ris</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s2">&quot;all_counterfactuals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">empty</span><span class="p">):</span>
                    
                    <span class="n">gen_counterfactuals</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s2">&quot;all_counterfactuals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                    <span class="c1">#EIGHTH COLUMN: probability prediction of multi-class classifier</span>
                    <span class="n">probab</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__mbbox_model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">gen_counterfactuals</span><span class="p">)</span>
                    <span class="n">max_prob</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">probab</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1">#NINTH COLUMN: distance between test sample and generated counterfactuals</span>
                    <span class="n">distances</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cdist_sample_distance</span><span class="p">(</span><span class="n">test_instance</span><span class="p">,</span><span class="n">gen_counterfactuals</span><span class="p">)</span>
    
                    <span class="c1">#FIVETH COLUMN: id of generated counterfactual</span>
                    <span class="n">gen_counterfactuals</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;ID_COUNTER&#39;</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="n">id_counterfactual</span><span class="p">,</span><span class="n">id_counterfactual</span><span class="o">+</span><span class="n">gen_counterfactuals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    
                    <span class="n">df_counterfactuals</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df_counterfactuals</span><span class="p">,</span><span class="n">gen_counterfactuals</span><span class="p">])</span>
    
                    <span class="k">for</span> <span class="n">index_counterfactual</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gen_counterfactuals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    
                        <span class="c1">#index_counterfactual used to get the exact counterfactual among the generated countefactuals</span>
                        
                        <span class="c1">#SIXTH COLUMN: counterfactual&#39;s class prediction of binary classifier </span>
                        <span class="n">counter_bbbox_pred</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s2">&quot;bbbox_predictions&quot;</span><span class="p">][</span><span class="n">index_counterfactual</span><span class="p">]</span>
                        <span class="c1">#SEVENTH COLUMN: counterfactual&#39;s class prediction of multiclass classifier </span>
                        <span class="n">counter_mbbox_pred</span><span class="o">=</span><span class="n">ris</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s2">&quot;mbbox_predictions&quot;</span><span class="p">][</span><span class="n">index_counterfactual</span><span class="p">]</span>
    
                        <span class="c1">## TO DEBUG</span>
                        <span class="c1">#print(f&quot;ID_TEST: {test_instance_id}&quot;)</span>
                        <span class="c1">#print(f&quot;orig_class_test: {y_labels[index]}&quot;)</span>
                        <span class="c1">#print(f&quot;mbbox_class_pred_test: {y_mbbox_predictions[index]}&quot;)</span>
                        <span class="c1">#print(f&quot;counter_class_desired: {label}&quot;)</span>
                        <span class="c1">#print(f&quot;ID_COUNTER: {gen_counterfactuals[&#39;ID&#39;][index_counterfactual]}&quot;)</span>
                        <span class="c1">#print(f&quot;bbbox_class_counter_pred: {counter_bbbox_pred}&quot;)</span>
                        <span class="c1">#print(f&quot;mbbox_class_counter_pred: {counter_mbbox_pred}&quot;)</span>
                        <span class="c1">#print(f&quot;mmbox_counter_class_prob: {float(max_prob[index_counterfactual]):.4f}&quot;)</span>
                        <span class="c1">#print(f&quot;counter_distance: {float(distances[0][index_counterfactual]):.4f}&quot;)</span>
                        
                        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index_position</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID_TEST&quot;</span><span class="p">:</span><span class="n">test_instance_id</span><span class="p">,</span>
                                                <span class="s2">&quot;orig_test_class&quot;</span><span class="p">:</span><span class="n">y_labels</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                                                <span class="s2">&quot;mbbox_test_class_pred&quot;</span><span class="p">:</span><span class="n">y_mbbox_predictions</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                                                <span class="s2">&quot;counter_class_desired&quot;</span><span class="p">:</span> <span class="n">label</span><span class="p">,</span>
                                                <span class="s2">&quot;ID_COUNTER&quot;</span><span class="p">:</span><span class="n">gen_counterfactuals</span><span class="p">[</span><span class="s2">&quot;ID_COUNTER&quot;</span><span class="p">][</span><span class="n">index_counterfactual</span><span class="p">],</span>
                                                <span class="s2">&quot;bbbox_counter_class_pred&quot;</span><span class="p">:</span><span class="n">counter_bbbox_pred</span><span class="p">,</span>
                                                <span class="s2">&quot;mbbox_counter_class_pred&quot;</span><span class="p">:</span><span class="n">counter_mbbox_pred</span><span class="p">,</span>
                                                <span class="s2">&quot;mmbox_counter_class_prob&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">max_prob</span><span class="p">[</span><span class="n">index_counterfactual</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span>
                                                <span class="s2">&quot;counter_distance&quot;</span><span class="p">:</span><span class="nb">float</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index_counterfactual</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                                               <span class="p">}</span>
                        <span class="n">index_position</span><span class="o">=</span><span class="n">index_position</span><span class="o">+</span><span class="mi">1</span>
                    <span class="n">id_counterfactual</span><span class="o">=</span><span class="n">id_counterfactual</span><span class="o">+</span><span class="n">gen_counterfactuals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index_position</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;ID_TEST&quot;</span><span class="p">:</span><span class="n">test_instance_id</span><span class="p">,</span>
                                                <span class="s2">&quot;orig_test_class&quot;</span><span class="p">:</span><span class="n">y_labels</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                                                <span class="s2">&quot;mbbox_test_class_pred&quot;</span><span class="p">:</span><span class="n">y_mbbox_predictions</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
                                                <span class="s2">&quot;counter_class_desired&quot;</span><span class="p">:</span> <span class="n">label</span><span class="p">,</span>
                                                <span class="s2">&quot;ID_COUNTER&quot;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;bbbox_counter_class_pred&quot;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;mbbox_counter_class_pred&quot;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;mmbox_counter_class_prob&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                                <span class="s2">&quot;counter_distance&quot;</span><span class="p">:</span><span class="kc">None</span>
                                           <span class="p">}</span>
                    <span class="n">index_position</span><span class="o">=</span><span class="n">index_position</span><span class="o">+</span><span class="mi">1</span>
        
        <span class="n">df_counterfactuals</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;./&quot;</span><span class="o">+</span><span class="n">dir_name</span><span class="o">+</span><span class="s2">&quot;/counterfactualset_&quot;</span><span class="o">+</span><span class="n">test_name</span><span class="o">+</span><span class="s2">&quot;.csv&quot;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;./&quot;</span><span class="o">+</span><span class="n">dir_name</span><span class="o">+</span><span class="s2">&quot;/results_&quot;</span><span class="o">+</span><span class="n">test_name</span><span class="o">+</span><span class="s2">&quot;.csv&quot;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>     </div>
</div>

        
<span class="c1">#pydoc.writedoc(&quot;MultiClass_CP_ILS&quot;)   </span>
<span class="c1">#ens_latent_spaces=MultiClass_CP_ILS(None,None,None,None,&quot;class&quot;,mode=&quot;1v1&quot;)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Davide Vigna.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>